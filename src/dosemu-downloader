#!/usr/bin/python3

import argparse
import hashlib
import os
import re
import shutil
import subprocess
import sys
import urllib.parse
import urllib.request
import zipfile
from pathlib import Path
from tqdm import tqdm

TMP_DIR = os.path.join('/tmp', os.path.basename(sys.argv[0]) + '-' + os.environ['USER'] + '-' + str(os.getpid()))

def download_file(source, destination_directory):
    destination_file = os.path.join(destination_directory, urllib.parse.unquote(source.split("/")[-1]))
    if Path(destination_file).is_file():
        if not destination_file.endswith('.txt'):
            check_sum(destination_file)
    else:
        print('Downloading ' + source + '...')
        with urllib.request.urlopen(urllib.parse.quote_plus(source, "\./_-:")) as response, open(destination_file, 'wb') as f:
            if hasattr(response, 'headers'):
                length = response.headers['Content-length']
            if length == None:
                length = response.getheader('content-length')
            if length == None:
                length = "1373281"
            print('Length = ' + length)
            if type(length) is str:
                with tqdm(total=int(length), unit='B') as pbar:
                    while True:
                        chunk = response.read(1024)
                        if not chunk:
                            break
                        f.write(chunk)
                        f.flush()
                        pbar.update(len(chunk))
                        pbar.refresh()
            else:
                f.write(response.read())
    return destination_file

def download_files(urls, destination):
    destination_files = []
    for url in urls:
        destination_files.append(download_file(url, destination))
    return destination_files

def calculate_sha256sum(filename):
    with open(filename,"rb") as f:
        return hashlib.sha256(f.read()).hexdigest();

def assert_sha256sum(file, sha256sum):
    val = calculate_sha256sum(file)
    if val == sha256sum:
        print('Verified checksum ' + str(file))
    else:
        print('The downloaded file ' + str(file) + ' could not be verified.')
        print('Actual   SHA256SUM: ' + val)
        print('Expected SHA256SUM: ' + sha256sum)
        print('Please remove the file and rerun the script.')
        sys.exit(1)

def process_disk_image_archive(archive, destination):
    image_archive = zipfile.ZipFile(archive)
    image_filename = image_archive.namelist()[0]
    image_archive.extractall(TMP_DIR)
    image_path = os.path.join(TMP_DIR, image_filename)
    subprocess.run(['mcopy', '-sn', '-i', image_path, '::*', destination], env={"PATH": os.environ['PATH'], "MTOOLS_LOWER_CASE": '1'})

def download_and_process(imgurls, destination, sha256sums = []):
    os.mkdir(TMP_DIR)
    destination_files = download_files(imgurls, TMP_DIR)
    for i, imgurl in enumerate(imgurls):
        if len(sha256sums) > 0:
            assert_sha256sum(destination_files[i], sha256sums[i])
    for destination_file in destination_files:
        if re.search(r'.zip$', destination_file) != None and len(zipfile.ZipFile(destination_file).namelist()) == 1:
            process_disk_image_archive(destination_file, destination)
        else:
            shutil.move(destination_file, destination)
    shutil.rmtree(TMP_DIR)

def verify_tool(executable, package):
    if subprocess.getstatusoutput(['which', executable]) == 0:
        print('Please install ' + package + ' and make sure that ' + executable + ' is on your PATH.')
        sys.exit(1)

def verify_system():
    verify_tool('mcopy', 'mtools')

def derive_url_list(imgurl):
    imgurls = []
    filename = urllib.parse.unquote(imgurl.split("/")[-1])
    if filename.casefold().find("disk") != -1:
        if filename.casefold().find("of") != -1:
            imgcnt = int(re.findall(r'(?i)disk\s?\d+\s?of\s(\d+)', filename)[0])
            for i in range(1, imgcnt+1):
                imgurls.append(imgurl.rsplit("/", 1)[0] + "/" + re.sub(r'(?i)(?P<one>disk\s?)\d+(?P<two>\s?of\s\d+)', r'\g<one>'+str(i) + r'\g<two>', filename))
        else: # if the filenames have just one number, assume the last disk from the set was provided
            imgcnt = int(re.findall(r'(?i)disk\s?(\d+)', filename)[0])
            for i in range(1, imgcnt+1):
                imgurls.append(imgurl.rsplit("/", 1)[0] + "/" + re.sub(r'(?i)(?P<one>disk\s?)\d+', r'\g<one>'+str(i), filename))
    else:
        imgurls.append(imgurl)
    return imgurls;

parser = argparse.ArgumentParser(description="""Script to download multiple URLs or a set of disk images.
When a URL to a disk image is provided, based on known filename patterns, all related images are downloaded and extracted.
Either a name should contain \"Disk ? of x\" or \"diskx\" where 1 is the first disk and x is the last disk.
The destination directory will contain all files from all disk images.""")
parser.add_argument("-c", "--custom",    help="Download specified disk/file set, requires a destination directory", nargs='+', type=str)
parser.add_argument("-d", "--destination", help="Specify/override the destination directory", type=str)
parser.add_argument("-s", "--sha256sum", help="Specify one or more sha256sum(s)", nargs='+', type=str)

args = parser.parse_args()
if args.custom and args.destination:
    urls = args.custom
    destination = args.destination
    os.makedirs(destination, exist_ok=True)
    if not os.listdir(destination):
        if len(urls) == 1:
            download_and_process(derive_url_list(urls[0]), destination, args.sha256sum if args.sha256sum else [])
        else:
            download_and_process(urls, destination, args.sha256sum if args.sha256sum else [])
    else:
        if args.sha256sum and not list(Path(destination).glob('*.sys')):
            for i, file in enumerate(Path(destination).iterdir()):
                assert_sha256sum(file, args.sha256sum[i])
        else:
            print('Continuing with existing file set in: ' + destination)
